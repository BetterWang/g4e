#compiler-settings
directiveStartToken = ^
commentStartToken = %
#end compiler-settings
%
%
%---CHEETAH SPECIAL SYMBOLS:---
%    % - cheetah comments
%    ^ - cheetah directives
%    $ - cheetah placeholders
%    # - C++ preprocessor
%   // - C++ comments
%
%
^import avr_naming_helper
%
//This file is auto generated by PythonGenerator program
#include "Global.h"
#include "${OutputFileName}.h"
#include <avr/eeprom.h>
#include <avr/pgmspace.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void Glb_Config_Init()
{
^for $item in $Items
    Glb_Config_${item.Category}_Init${item.BaseName}();
^end for

    //Call user defined function on update
    Glb_Config_OnUpdate();
}

%---I don't use any indents here for the proper indents in the output C++ code---
%---There is an '^end for' directive in Cheetah, though---
^for $item in $Items
%---Set some local variables---
^set $eepType = avr_naming_helper.get_eeprom_value_type($item.ValueType)
^set $avrType = avr_naming_helper.get_avr_value_type($item.ValueType)
^set $eepTypeName = avr_naming_helper.get_eeprom_type_name($item.ValueType)
^set $isArray = avr_naming_helper.is_array($item.ValueType)
^set $name = $item.BaseName
^set $category = $item.Category
^set $eepVariableName = "eep_" + $category + "_" + $name
^set $glbVariableName = "glb_" + $category + "_" + $name


/** -------------------------------------------------------------------------------------
 *
 * $item.Description
 *
 */
%---We have to generate different code for array and non-array config items---
%---So, it's where an '^if' goes---
^if $isArray
$eepType EEMEM ${eepVariableName}[] = {$item.DefaultValues};
$avrType ${glbVariableName}[] = {$item.DefaultValues};

void Glb_Config_${category}_Init${name}()
{
    while(!eeprom_is_ready());
    eeprom_read_${eepTypeName}($glbVariableName, $eepVariableName, sizeof($glbVariableName));
}

void Glb_Config_${category}_Set${name}($avrType *value)
{
    while(!eeprom_is_ready());
    memcpy($glbVariableName, value, sizeof($glbVariableName));
	eeprom_update_${eepTypeName}($glbVariableName, $eepVariableName, sizeof($glbVariableName));
}

void Glb_Config_${category}_Get${name}($avrType *destination)
{
	memcpy(destination, $glbVariableName, sizeof($glbVariableName));
    return;
}
%---It's time for non-array items---
^else
$eepType EEMEM $eepVariableName = $item.DefaultValue;
$avrType $glbVariableName = $item.DefaultValue;

void Glb_Config_${category}_Init${name}()
{
    while(!eeprom_is_ready());
    $glbVariableName = eeprom_read_${eepTypeName}(&$eepVariableName);
}

void Glb_Config_${category}_Set${name}($avrType  value)
{
    while(!eeprom_is_ready());
    $glbVariableName=value;
	eeprom_update_${eepTypeName}(&$eepVariableName, $glbVariableName);
}

$avrType Glb_Config_${category}_Get${name}()
{
    return $glbVariableName;
}
^end if
^end for



bool Glb_Config_ProtocolParse(char* requestBuffer, uint8_t requestStartIndex, char* responseBuffer, uint8_t responseStartIndex)
{
^for $item in $Items
^set $eepType = avr_naming_helper.get_eeprom_value_type($item.ValueType)
^set $avrType = avr_naming_helper.get_avr_value_type($item.ValueType)
^set $name = $item.BaseName
^set $category = $item.Category
^set $sscanfKey = avr_naming_helper.get_sscanf_key($item.ValueType)
^set $setCommandLength = len($item.SetCommand)
^set $isArray = avr_naming_helper.is_array($item.ValueType)

^if $isArray
^set $n = int($item.ArrayLength)
    /* === $name === */
    /* $item.Description */
    //SET
    if( strstr(requestBuffer,"$item.SetCommand "))
    {
        $avrType value[$n];
    ^if $item.ValueType == 'Float[]'
    	requestBuffer[strlen(requestBuffer) - 5] = 0;
		char* lastSpace;
		for (uint8_t i = 0; i < $n; i++)
		{
			lastSpace = strrchr(requestBuffer, ' ');
			value[$n-i-1] = atof(lastSpace + 1);
			*lastSpace = 0;
		}
    ^else
    %--- If the item is an integer array ---
    %---(the ^slurp directive gobbles the EOL)---
        sscanf_P(&requestBuffer[$setCommandLength], PSTR("^slurp
^repeat $n
 $sscanfKey^slurp
^end repeat
")^slurp
^for $i in $range($n)
, &value[$i]^slurp
^end for
);
    ^end if
    	Glb_Config_${category}_Set${name}(value);
		Glb_Config_OnUpdate();
		responseBuffer[responseStartIndex] = 'Y';
		responseBuffer[3] = 0;
		return true;
    }

	//GET
	if (strstr(requestBuffer, "$item.GetCommand "))
	{
		$avrType value[$item.ArrayLength];
		Glb_Config_${category}_Get${name}(value);
		sprintf_P(&responseBuffer[responseStartIndex], PSTR("$item.GetCommand"));
		for (uint8_t i = 0; i < $item.ArrayLength; i++)
		{
			sprintf_P(&responseBuffer[strlen(responseBuffer)], PSTR(" $sscanfKey"), value[i]);
		}
		return true;
	}
^else
%--- If the item is not an array: ---
    /* === $name === */
    /* $item.Description */
    //SET
    if( strstr(requestBuffer,"$item.SetCommand "))
    {
  ^if $item.ValueType == 'Float'
        //Have to use atof for float. So have to set line termination
        //usual request has space before checksum
        //like 'NCFGHB 1.000000 FF12', so we cut the string from [NCFGHB_len + 1:request_len-5]
        requestBuffer[strlen(requestBuffer)-5]=0;
        Glb_Config_${category}_Set${name} (atof(&requestBuffer[$setCommandLength + 1]));
  ^else
        $avrType value;
        sscanf_P(&requestBuffer[$setCommandLength + 1], PSTR("$sscanfKey"), &value);
        Glb_Config_${category}_Set${name}(value);
  ^end if
        Glb_Config_OnUpdate();
        responseBuffer[responseStartIndex]='Y';
        responseBuffer[3]=0;
        return true;
    }

    //GET
    if( strstr(requestBuffer,"$item.GetCommand "))
    {
        sprintf_P(&responseBuffer[responseStartIndex], PSTR("$item.GetCommand $sscanfKey "), Glb_Config_${category}_Get${name}());
        return true;
    }
^end if

^end for

    return false;
}